<!DOCTYPE HTML>
<html lang="en">
<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
  <title></title>
  <style>
      body {background-color: #232937; margin: 0 auto; max-width: 700px; background-color: #232937; 
            padding: 15px; 
            font-family:Source Sans Pro, Arial,Baskerville,monospace; color: #fff;
            font-weight: 300; size: 15.4px;}
     .top {font-family: Source Sans Pro; font-size: 46.2px; font-weight: bold; text-align: center}
     .canvas {margin: 0 auto; border: 1px solid white; width: 400px; height: 400px;cursor: none}
     .player1 {margin: 0 auto; font-family: Source Sans Pro; color: #27C97B; width: 400px;
               font-size: 46.2px; font-weight: bold; text-align: center}
               
     .player2 {margin: 0 auto; font-family: Source Sans Pro; color: #00BCD4; width: 400px;
               font-size: 46.2px; font-weight: bold; text-align: center}
  </style>
 </head>
<body onload="setInterval(loop,1000/30);">  
<div>
  <div class="top">DOTS</div>
  <div id="container" class="canvas" onclick="click()"></div>
  <div id="player1" class="player1"></div>
  <div id="player2" class="player2"></div>
  
  <div id="debug" style="display: none">
    <table><tr>
    <td>Input:<td><input type="text" id="inN" /><br></tr>
    <tr><td>Output:<td><textarea id="out1" cols=40 rows=6></textarea><br></tr>
    <tr><td><button onclick="update()" >Go=></button></tr>

    <tr><td><button onclick="makeSquares()">Make=></button></tr>
    <tr><td>Squares:<td><input id="sqCount"" type=text>
    <tr><td>Layout:<td><textarea rows=6 cols=40 id="out2"></textarea>

    <tr><td>Line:<td>x1:<input id="x1" type="text"><td>y1:<input id="y1" type="text">
    <tr><td><td>x2:<input id="x2" type="text"><td>y2:<input id="y2" type="text">
    </table>
  </div> <!--end debug-->
</div>
  
  <script type="text/javascript">
    var player = 0;
    var score = [0,0];
    var click1 = new Point (-1, -1);
    var click2 = new Point (-1, -1);
    var pointArr = new Array();
    var squareArr = new Array();
    var linesArr = new Array();
    var squareid = 0;
    var n = 0;
    var padding = 25;
    var spacing = 380;
    var mousePos;
    var message;
    var cycle = 0;
    var loopCount = 0;
    //CANVAS VARS
    var container, canvas, context;
    var w = 400; var h = 400;
    init();
    
    function loop() {
      drawDots();
      getScore();
      drawLines();
      cycle = Math.sin(loopCount);
      loopCount+=0.1;
    }
        
    function getMousePos(canvas, evt) {
      var rect = canvas.getBoundingClientRect();
      x = evt.clientX - rect.left;
      y = evt.clientY - rect.top;
      dotx = Math.floor((x / (spacing/n)));
      doty = Math.floor((y / (spacing/n)));
      return { x, y, dotx, doty };
    } 

    function init() {
      container = document.getElementById('container');
      canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      container.appendChild(canvas);
      context = canvas.getContext("2d");
      //context.translate(0.5, 0.5);
      context.fillStyle = "#282E3E";
      context.fillRect(0, 0, w, h);
      canvas.addEventListener('mousemove', function(evt) {mousePos = getMousePos(canvas, evt);}, false);
      canvas.addEventListener('click', function(evt) {
        mousePos = getMousePos(canvas, evt);
        
        //reset event
        if (click1.x == mousePos.dotx && click1.y == mousePos.doty) { click1 = new Point (-1, -1); click2 = new Point (-1, -1)}
        
        //first click
        else if (click1.x == -1) {
          click1.x = mousePos.dotx;
          click1.y = mousePos.doty;
          $("#x1").val(click1.x);
          $("#y1").val(click1.y);
          //check if open
          
          //highlight adjacent open
        }
        
        //second click
        else if (click2.x == -1) {
          click2.x = mousePos.dotx;
          click2.y = mousePos.doty;
          inLine = new Line (new Point(click1.x,click1.y), new Point(click2.x,click2.y))
          checkLine(inLine);
        }
      }, false);
      //auto init
      n = 13;
      update();
      makeSquares();
    }
    
    
    // Setup Initial Grid
    function update(){
      //n = $("#inN").val();
      output = "n: " + n + "\n" + "Total Points: " + n*n + "\n";
      count = 0;
      for (x=0;x<n;x++){
        for (y=0;y<n;y++){
          pointArr.push(new Point(x,y))
          output += "(" + pointArr[count].x + "," + pointArr[count].y + ")";
          count ++;
        }
        output += "\n"
      }
      $("#out1").val(output);
    }
    
    //Point Class
    function Point (x,y)
    {
      this.x = x;
      this.y = y;
    }
    
    // Square Class
    function Square (){
      this.id = squareid;
      this.points = new Array();
      this.lines = new Array();
      this.owner = -1;
      squareid++;
    }
   
    // Line Class
    function Line (p1, p2, open){
      this.p1 = p1;
      this.p2 = p2;
      this.open = open;
    }
    
    // Find all of the coords for each corner of each square and build array
    function makeSquares(){
      sq = Math.pow((n-1),2);
      for (i=0;i<sq;i++){
        squareArr.push(new Square);
      }
      $("#sqCount").val(sq);
      output2 = "";
      for (i = 1; i <= sq; i++){
        row = Math.ceil(i/(n-1));
        col = (i - ((n-1) * (row - 1)));
        squareArr[i-1].points.push(new Point(col -1, row -1));
        squareArr[i-1].points.push(new Point(col,    row -1));
        squareArr[i-1].points.push(new Point(col,    row));
        squareArr[i-1].points.push(new Point(col -1, row));
        
        // lines
        squareArr[i-1].lines.push(new Line(squareArr[i-1].points[0], squareArr[i-1].points[1],true));
        squareArr[i-1].lines.push(new Line(squareArr[i-1].points[1], squareArr[i-1].points[2],true));
        squareArr[i-1].lines.push(new Line(squareArr[i-1].points[2], squareArr[i-1].points[3],true));
        squareArr[i-1].lines.push(new Line(squareArr[i-1].points[3], squareArr[i-1].points[0],true));
         
        output2 += "Sq: " + (i-1) + " :: " 
            + "(" + squareArr[i-1].points[0].x + ", " + squareArr[i-1].points[0].y + ") " 
            + "(" + squareArr[i-1].points[1].x + ", " + squareArr[i-1].points[1].y + ") "
            + "(" + squareArr[i-1].points[2].x + ", " + squareArr[i-1].points[2].y + ") "
            + "(" + squareArr[i-1].points[3].x + ", " + squareArr[i-1].points[3].y + ") \n  "
            + "0. (" + squareArr[i-1].lines[0].p1.x + "," + squareArr[i-1].lines[0].p1.y + ") --> "
            + "(" + squareArr[i-1].lines[0].p2.x + "," + squareArr[i-1].lines[0].p2.y + ")\n  "
            + "1. (" + squareArr[i-1].lines[1].p1.x + "," + squareArr[i-1].lines[1].p1.y + ") --> "
            + "(" + squareArr[i-1].lines[1].p2.x + "," + squareArr[i-1].lines[1].p2.y + ")\n  "
            + "2. (" + squareArr[i-1].lines[2].p1.x + "," + squareArr[i-1].lines[2].p1.y + ") --> "
            + "(" + squareArr[i-1].lines[2].p2.x + "," + squareArr[i-1].lines[2].p2.y + ")\n  "
            + "3. (" + squareArr[i-1].lines[3].p1.x + "," + squareArr[i-1].lines[3].p1.y + ") --> "
            + "(" + squareArr[i-1].lines[3].p2.x + "," + squareArr[i-1].lines[3].p2.y + ")\n  ";
        $("#out2").val(output2)
      }
    }
    
    // Paint a dot
    function paintDot(x,y,rad,color){
      context.beginPath();
      context.arc(x,y,rad, 0, 2 * Math.PI, false);
      context.fillStyle = color;
      context.fill();
    }
    
    // Paint the Cursor
    function paintCursor(x,y,rad,color){
      grad = context.createLinearGradient(x-rad,y,x+rad,y);
      grad.addColorStop("0.5",'#962FE4');
      grad.addColorStop("1.0",'#DC398B');
      context.beginPath();
      context.arc(x,y,rad, 0, 2 * Math.PI, false);
      context.fillStyle = color;
      context.lineWidth = 1.5;
      context.strokeStyle = grad;
      context.stroke();        
    }
    
    function drawDots(){
      //Background
      context.fillStyle = "#282E3E";
      context.fillRect(0, 0, w, h);
      //All Dots
      for (i = 0; i < pointArr.length; i++) {
	     point = pointArr[i];
       paintDot((point.x * spacing/n) + padding, (point.y * spacing/n) + padding, 3.5, "#999");
	    }
      //cursor dots
      if (player == 0) color = "rgb(39,200,122)";
      if (player == 1) color = "rgb(0,128,212)";
      
      if (mousePos.dotx < n && mousePos.doty < n){ paintCursor((mousePos.dotx * spacing/n) + padding, (mousePos.doty * spacing/n) + padding, 15,"rgba(0,255,0,0.25)"); }
      if (click1.x > -1){ paintDot((click1.x * spacing/n) + padding, (click1.y * spacing/n) + padding, 5, color); }
      if (click2.x > -1){ paintDot((click2.x * spacing/n) + padding, (click2.y * spacing/n) + padding, 5, color); }
      
    }
    function drawLines(){
      for (i=0; i < squareArr.length; i++ ) {
        for (j=0; j < 4; j++){
          if (squareArr[i].lines[j].open == false) {
            context.beginPath();
            context.moveTo((squareArr[i].lines[j].p1.x * spacing/n) + padding,
                           (squareArr[i].lines[j].p1.y * spacing/n) + padding);
            context.lineTo((squareArr[i].lines[j].p2.x * spacing/n) + padding,
                           (squareArr[i].lines[j].p2.y * spacing/n) + padding);
            context.lineWidth = 1;
            context.strokeStyle = 'white';
            context.stroke();
          } 
        }
        if (squareArr[i].owner > -1){
          color = "#ffffff";
          if (squareArr[i].owner == 0 ) color =  "rgb(39,200,122)";
          else  color = "rgb(0,128,212)";
          context.fillStyle = color;
          context.fillRect(((squareArr[i].points[0].x * spacing)/n) + padding, 
                           ((squareArr[i].points[0].y * spacing)/n) + padding,spacing/n,spacing/n);
        }
      }
    }
    
    function getScore(){
        if (player == 1 ){
          $("#player1").css("border","solid 1px #27C97B");
          $("#player2").css("border","solid 1px #232937");
        }
        else {
          $("#player1").css("border","solid 1px #232937");
          $("#player2").css("border","solid 1px #00BCD4");
        }
        $("#player1").text("Player 1 : " + score[0]);
        $("#player2").text("Player 2 : " + score[1]);
    }
    
    function checkLine(inLine){
      if (lineOpen(inLine)) {
        //advance player
        if (player == 0) player=1 
        else player=0;
        // Close the line
        closeLine(inLine);
        // Check for new squares
        var lineCount = 0;
        var squareCount = 0;
        var newLine = 1;
        // a While to keep checking the map when a line is updated
        while (newLine == 1) {
          // go through all squares
          var i = 0;
          for (i=0; i < squareArr.length; i++ ) {
            // don't bother with owned ones
            if (squareArr[i].owner == -1) {
              lineCount = 0;
              // see if these are three lines
              var j = 0;
              for (j=0; j < 4; j++) {if (squareArr[i].lines[j].open == false) lineCount++;};
              if (lineCount >= 3){
                //find and close the fourth line
                for (j=0; j < 4; j++) { closeLine(squareArr[i].lines[j]); }                
                squareArr[i].owner = player;
                score[player]++;
                squareCount++;
              }                   
            }
          }
          if (squareCount == 0) newLine = 0;
          else if (squareCount > 0) squareCount = 0;
        }
        
        //reset dots
        click1 = new Point (-1, -1); click2 = new Point (-1, -1);

      }
      else {
        alert("Already taken!");
        click1 = new Point (-1, -1); click2 = new Point (-1, -1);
      }
    }
        
    function lineOpen(inLine){
      status = false;
      for (i=0; i < squareArr.length; i++ ) {
        for (j=0; j < 4; j++){
          if (lineMatch(inLine, squareArr[i].lines[j])) {
            if (squareArr[i].lines[j].open == true) status = true;
          }
        }
      }
      return status;
    }
    
    function closeLine(inLine){
      for (i=0; i < squareArr.length; i++ ) {
        for (j=0; j < 4; j++){
          if (lineMatch(inLine, squareArr[i].lines[j])) squareArr[i].lines[j].open = false;
        }
      }
    }
    
    function lineMatch( in1, in2){
      //alert("Line Match: "  + in1.p1.x + ":" + in1.p1.y + "::" + in1.p2.x + ":" + in1.p2.y);
      //alert("Line Match: "  + in2.p1.x + ":" + in2.p1.y + "::" + in2.p2.x + ":" + in2.p2.y);
      if (pointMatch(in1.p1,in2.p1) && pointMatch(in1.p2,in2.p2)) return true;
      if (pointMatch(in1.p1,in2.p2) && pointMatch(in1.p2,in2.p1)) return true;
      return false;
    }
    
    function pointMatch(p1,p2){
      //alert(p1.x + ":" + p2.x + "    " + p1.y + ":" + p2.y);
      if (p1.x == p2.x && p1.y == p2.y) return true;
      return false;
    }
  </script>
</body>
</html>
